<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Blog | Jiahao's Blog</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- KaTeX for math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/marked-katex-extension@5.1.4/lib/index.umd.js"></script>
</head>
<body>
    <div class="container">
        <nav class="navbar">
            <div class="navbar-left">
                <a href="index.html" class="nav-link nav-link-underline">Home</a>
            </div>
            <div class="navbar-right">
                <a href="blog.html" class="nav-link nav-link-underline" id="blogs-link">Blogs</a>
            </div>
        </nav>
        <div class="navbar-divider">
            <div id="post-metadata" class="post-metadata-container"></div>
        </div>
        <main class="main-content blog-centered">
            <div id="blog-list" class="blog-list"></div>
            <div id="blog-detail" class="blog-detail" style="display:none;"></div>
        </main>
    </div>
    <script>
    // Configure marked options
    marked.use({
      breaks: true,
      gfm: true,
      headerIds: true,
      mangle: false
    });

    // Use KaTeX extension for marked
    // Check if markedKatex is available (it's loaded via defer)
    // We need to ensure markedKatex is loaded before marked.use is called if it's not part of the global scope immediately.
    // A simple way for now is to assume it will be available when parsing happens.
    // More robust would be to wrap dependent code in a DOMContentLoaded or ensure scripts are loaded in order without defer for critical ones.
    
    // Let's initialize it when the main script runs. It should be available if scripts are parsed.
    if (typeof markedKatex === "function") {
      marked.use(markedKatex({ throwOnError: false }));
    } else {
      // Fallback or error if markedKatex is not loaded - for now, we'll assume it loads.
      // Consider adding it inside the fetch().then() block if issues persist.
      console.warn("markedKatex extension not loaded yet. Math rendering might fail.");
    }
    
    // Format date function
    function formatDate(dateStr) {
      if (!dateStr) return '';
      const d = new Date(dateStr);
      return d.toISOString().slice(0, 10);
    }

    // Card click animation
    function addCardClickEffect() {
      document.querySelectorAll('.blog-card').forEach(card => {
        card.addEventListener('click', function(e) {
          if (e.target.tagName === 'A' || e.target.closest('a')) {
            // Create ripple effect
            const ripple = document.createElement('div');
            ripple.className = 'ripple-effect';
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            ripple.style.left = x + 'px';
            ripple.style.top = y + 'px';
            
            this.appendChild(ripple);
            
            setTimeout(() => {
              ripple.remove();
            }, 600);
          }
        });
      });
    }

    // Render blog list with animation
    function renderBlogList(posts) {
      const list = document.getElementById('blog-list');
      list.innerHTML = '';
      
      // Clear metadata area
      document.getElementById('post-metadata').innerHTML = '';
      
      // Create and append blog cards with staggered animation
      posts.forEach((post, index) => {
        const card = document.createElement('div');
        card.className = 'blog-card';
        card.style.opacity = '0';
        card.style.transform = 'translateY(20px)';
        card.style.transition = `all 0.5s ease ${index * 0.1}s`;
        
        card.innerHTML = `
          <div class="blog-card-content">
            <h2 class="blog-card-title">
              <a href="#${post.filename}" class="blog-title-link">${post.title}</a>
            </h2>
            <p class="blog-card-summary">${post.summary}</p>
            <div class="blog-card-meta">
              <span class="blog-card-date">${formatDate(post.date)}</span>
            </div>
          </div>
        `;
        
        list.appendChild(card);
        
        // Trigger animation after a short delay
        setTimeout(() => {
          card.style.opacity = '1';
          card.style.transform = 'translateY(0)';
        }, 10);
      });
      
      list.style.display = 'flex';
      document.getElementById('blog-detail').style.display = 'none';
      
      // Add click effects after rendering
      setTimeout(addCardClickEffect, 100);
    }

    // Render blog detail with animation
    function renderBlogDetail(post, md) {
      const detail = document.getElementById('blog-detail');
      // Process the markdown content
      // Initialize markedKatex here if it wasn't available earlier, or right before parsing.
      if (typeof markedKatex === "function" && !marked.options.highlight) { // Check if not already added, crude check
        // This is a bit tricky with `marked.use` as it's usually global.
        // The earlier initialization should suffice if markedKatex is loaded.
      }
      const htmlContent = marked.parse(md);
      
      // Hide detail initially for transition
      detail.style.opacity = '0';
      detail.style.transform = 'translateY(20px)';
      
      // Update post metadata under the divider
      const metadataArea = document.getElementById('post-metadata');
      metadataArea.innerHTML = `
        <h1 class="post-title">${post.title}</h1>
        <span class="post-date">${formatDate(post.date)}</span>
      `;
      
      detail.innerHTML = `
        <div class="blog-content">${htmlContent}</div>
      `;
      
      detail.style.display = 'block';
      document.getElementById('blog-list').style.display = 'none';
      
      // Trigger animation
      setTimeout(() => {
        detail.style.opacity = '1';
        detail.style.transform = 'translateY(0)';
      }, 10);
    }

    // Main logic
    let blogPosts = [];
    
    // Add page transition effect
    function addPageTransition(callback) {
      const transitionOverlay = document.createElement('div');
      transitionOverlay.className = 'page-transition-overlay';
      document.body.appendChild(transitionOverlay);
      
      transitionOverlay.style.opacity = '1';
      
      setTimeout(() => {
        callback();
        transitionOverlay.style.opacity = '0';
        
        setTimeout(() => {
          document.body.removeChild(transitionOverlay);
        }, 500);
      }, 300);
    }
    
    fetch('assets/blog-index.json')
      .then(res => res.json())
      .then(posts => {
        blogPosts = posts;

        // It's safer to initialize marked.use(markedKatex) here,
        // ensuring markedKatex UMD module is loaded and parsed.
        if (typeof markedKatex === "function") {
            marked.use(markedKatex({ throwOnError: false }));
        } else {
            // This might happen if the UMD script for markedKatex hasn't executed yet.
            // A more robust solution is to ensure script load order or use modules.
            // For now, let's log a warning. If Math doesn't work, this is the first place to check.
            console.warn("markedKatex function not found when trying to initialize in fetch. Math may not render.");
        }
        
        function route() {
          const hash = decodeURIComponent(window.location.hash.replace(/^#/, ''));
          
          if (!hash) {
            renderBlogList(blogPosts);
          } else {
            const post = blogPosts.find(p => p.filename === hash);
            if (!post) {
              renderBlogList(blogPosts);
              return;
            }
            
            fetch('assets/' + post.filename)
              .then(res => res.text())
              .then(md => renderBlogDetail(post, md));
          }
        }
        
        // Add click handler for blogs link
        document.getElementById('blogs-link').addEventListener('click', function(e) {
          if (window.location.pathname.includes('blog.html')) {
            e.preventDefault();
            window.location.hash = '';
          }
        });
        
        window.addEventListener('hashchange', route);
        route();
      });
    </script>
</body>
</html>